---
title: Финансовые данные -- получение, особенности и трансформация.<br> Количественные
  финансы
author: "Салихов Марсель (marcel.salikhov@gmail.com)"
date: "`r Sys.Date()`"
output:
  slidy_presentation:
    css: styles.css
    footer: НИУ ВШЭ. Салихов Марсель (marcel.salikhov@gmail.com)
    lib_dir: libs
    self_contained: no
---
   
## Цели лекции 
   
+ понять, в чем отличия **финансовых данных** от других типов данных
+ изучить основные источники финансовых данных, которые могут быть загружены в R
+ получить навыки **трансформирования** финансовых данных
+ изучить особенности расчета **доходностей**
+ разобраться, как и зачем осуществляется **корректировка** на выплаты дивидендов
+ изучить основные особенности финансовых данных с точки зрения статистики
+ понять, что такое **стационарность** временных рядов и почему это важно 

## Финансовые данные 

+ Важность количественных методов в бизнесе и финансах увеличивается по мере того, как появляется большее количество информации и данных.
+ Финансовые данные систематически собираются в больших количествах и все с большей временной точностью. Достаточно большое количество финансовых данных доступно абсолютно бесплатно.  
+ Финансовых данных как правило достаточно **много** по сравнению с другими областями. Вопрос обычно состоит не в том, что данных нет, а в том, чтобы эффективно использовать доступные данные и получить содержательные результаты.
+ В `R` есть множество пакетов, которые позволяют загружать финансовые данные напрямую. Вам не надо заходить куда-то в интернете, скачивать/экспортировать данные, сохранять их на свой компьютер, разбираться форматом хранения, загружать и проч. Обычно загрузка серии -- это одна строка кода. 
+ Основной пакет, который мы будем использовать для получения зарубежных данных финансовых серий -- [`quantmod`](https://cran.r-project.org/web/packages/quantmod/index.html), для российских данных -- [`QuantTools`](https://cran.r-project.org/web/packages/QuantTools/index.html) (данные ФИНАМа).
+ Источники бесплатных данных по финансовым рынкам -- Yahoo Finance, Google Finance, FRED, Quandl, для России -- Финам, Банк России, Московская Биржа. 
+ Источники платных данных по финансовым рынкам -- системы Bloomberg, Thomson Reuters (Eikon). Есть провайдеры данных только по ценам на финансовые активы -- CQG, AlgoSeek,  QuantQuote и другие. 

## Модель работы с количественными данными 

```{r, echo=FALSE, warning=FALSE, message=FALSE }
#Sys.setlocale(locale = "ru_RU.UTF-8")

require(DiagrammeR)

mermaid("
graph TB
  A[Получение первичных данных]-->B[Преобразование/трансформация данных]
  B-->C[Построение количественной модели]
  C-->E[Диагностика/тестирование модели]
  E-->C
style A font-size:50px
style B font-size:50px
style C font-size:50px
style E font-size:50px
", width = 800)

```


## Получение финансовых данных с помощью quantmod и QuantTools

```{r setup, cache=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
library("RColorBrewer")    # brewer.pal
library("e1071")           # kurtosis
library("knitr")           # opts_chunk
library(QuantTools)
require(ggplot2)
library(quantmod)
library(xts)

# utility functions
#source("http://ptrckprry.com/course/forecasting/code/ad.test.R")

options(width = 80)

# color palette
palette(brewer.pal(6, "Set1"))

opts_chunk$set(fig.width=12, fig.height=6, fig.align="center", echo=FALSE, tidy=FALSE)
opts_chunk$set(cache=TRUE, fig.align="center", comment=NA, echo=FALSE, tidy=FALSE)

# преобразовать объект xts в dataframe с сохранением индекса даты
quant_tools_to_xts <- function(df, ...){ 
  df <- as.data.frame(df)
  #df$date = as.Date(df$date)
  ts = xts(df[,-1], order.by = df[,1])
  return(ts)
}


# преобразовать объект xts в dataframe с сохранением индекса даты
XtstoDf <- function(ts, ...){ 
  df <- as.data.frame(ts)
  df$date <- time(ts)
  return(df)
}
# encapsulate the plotting commands into a function so that we don't have to repeat ourselves
fancy.plot <- function(x, y, hguide=0, vguide=0, type = "p", col = "black", pch = 1, cex = 1, ...) {
    # set up plot region
    plot(x, y, type="n", axes=FALSE, ...)
    
    # add axes
    Axis(x, side=1, lwd=0, lwd.ticks=1, labels=TRUE)
    Axis(y, side=2, lwd=0, lwd.ticks=1, labels=TRUE)
    Axis(x, side=3, lwd=0, lwd.ticks=1, labels=FALSE)
    Axis(y, side=4, lwd=0, lwd.ticks=1, labels=FALSE)
    
    # add horizontal guide lines
    usr <- par("usr")
    if (hguide > 0) {
        abline(h=seq(usr[3], usr[4], length.out=hguide+2)[-c(1,hguide+2)], col="gray")
    }
    if (vguide > 0) {
        abline(v=seq(usr[1], usr[2], length.out=vguide+2)[-c(1,vguide+2)], col="gray")
    }

    # add the data
    if (type == "l") {
        lines(x, y, col=col)
    } else if (type == "p") {
        points(x, y, cex=cex, pch=pch, col=col)
    }
    
    # add frame
    box()
}

getSymbols("^GSPC",src="yahoo", from ='1950-01-01') # from yahoo finance 
write.csv(XtstoDf(GSPC), 'data/sp500.csv', row.names = FALSE)
load('../.RData')
sp500 <- read.csv('data/sp500.csv')
getSymbols("XOM", src = 'yahoo', from = '01-01-1990')
#tail(sp500)

```


```{r, echo=TRUE, eval=FALSE, warning=FALSE}
library(quantmod) # загрузка пакет
getSymbols("^GSPC", src="yahoo", from ='1950-01-01') #  yahoo finance 
tail(GSPC)
library(QuantTools)
micex <- get_finam_data('MICEX', from = '2012-01-01', to = Sys.Date()) # индекс ММВБ 
# пакет QuantTools возвращает данные в формате data.table/data.frame, а не хts
class(micex)
micex <- quant_tools_to_xts(micex)
tail(micex)
```

+ Обычно у каждой серии есть свой уникальный идентификатор (`id`) -- **тикер** -- это текстовый код - аббревиатура. Но в разных источниках могут использоваться разные тикеры для одной и той же серии. Поэтому проверяйте тикеры, чтобы удостовериться, что источники возвращают вам те данные, что вам нужны. 
К примеру, индекс S&P 500 имеет тикер `SPX` в Bloomberg, `^GSPC` -- в Yahoo Finance, `INDEXSP:.INX` -- в Google Finance, `SP500` -- во FRED.  

## Получение данных из Quandl

+ Сервис `Quandl` представляет собой удобный сервис для доступа к разным наборам финансовых/экономических данных "в одном месте". Существуют как платные, так и бесплатные датасеты. 
+ Для того, чтобы получать данные с Quandl необходимо зарегестрироваться на сайте и получать свой уникальный ключ доступа (API Key)

```{r, eval=FALSE, echo=TRUE}
require(Quandl)

# Crude Oil Futures, Continuous Contract #31 (CL31)
#Quandl.api_key("BLQfNYvHf1E6vFusHAT4")# ваш собcтвенный API Key
#cl <-  Quandl("EIA/PET_RWTC_D") 

```

построим график полученной серии 

```{r, echo=TRUE}
head(cl,10)
plot(x = cl$Date, y = cl$Value, type = 'l', ylab ='$/баррель', xlab = "", 
     main = 'Динамика цен на нефть WTI')
```

<!-- ## Получение данных финансовой отчетности с помощью пакета tidyquant -->

<!-- + `tidyquant` представляет собой еще один пакет, который обеспечивает доступ к данным из разных источников, а также функации для преобразования и визуализации финансовых данных.  -->
<!-- + `tidyquant` в том числе обеспечивает доступ к данным финансовой отчетности компаний США (источник данных -- Google Finance), которая включается в себя (Income Statement, Balance Sheet, and Cash Flow) c разной периодичностью (годовая/annual и квартальная/quarter). -->

<!-- ```{r, echo=TRUE, warning=FALSE, message=FALSE} -->
<!-- require(tidyquant) -->
<!-- require(dplyr) -->
<!-- aapl_financials <- tq_get("AAPL", get = "financials") -->
<!-- ``` -->

<!-- Информация может быть извлечена с помощью функцию пакета `dplyr'.  -->


<!-- ```{r,  warning=FALSE, echo=TRUE} -->
<!-- aapl_financials %>% -->
<!--     unnest(quarter) %>%  -->
<!--     spread(key = date, value = value) -->
<!-- ``` -->

<!-- можно также получить данные по ключевой статистике американских эмитентов (источник -- Morningstar) -->

<!-- ```{r, echo=TRUE } -->
<!-- aapl_key_ratios <- tq_get("AAPL", get = "key.ratios") -->
<!-- aapl_key_ratios %>% -->
<!--     dplyr::filter(section == "Valuation Ratios") %>% -->
<!--     unnest() %>% -->
<!--     ggplot(aes(x = date, y = value)) +  -->
<!--     geom_line(aes(col = forcats::fct_reorder2(category, date, value)), -->
<!--               size = 1) + -->
<!--     labs(title = "Исторические метрики для AAPL за последние 10 лет", x = "",  -->
<!--          y = "", col = "") + -->
<!--     theme_tq() + -->
<!--     scale_color_tq() -->
<!-- ``` -->

## Данные Alpha Vantage 

```{r, message=FALSE, warning=FALSE}
require(quantmod)
api.key <-  "2U5M4KUU3VXJZRLO"
getSymbols("MSFT", src = "av", api.key = api.key) 
tail(MSFT)
```



## Чтение данных из заранее сохраненных файлов 

+ Формат `.csv` является наиболее простым и распространенным вариантам хранения небольших объемов финансовых данных. Файл csv (comma separated values) является просто текстовым файлом, в котором записана таблица данных (обычно использется запятая для того, чтобы разделить данные из разных столбцов)
+ В R используются команды `write.csv` и `read.csv` для записи и чтения файлов csv
+ У вас также есть возможность читать/записывать данные в формат Excel, но лучше это делать для итогового варианта и не использовать Excel для хранения исходных данных. 
+ Вы можете подготовить необходимые данные в Excel, экспортировать их в csv, а потом прочитать csv-файл в R. 
+ Для чтения больших файлов csv лучше использовать специальных функции `fread/fwrite` из пакета `data.table`.

```{r, echo=TRUE}
#write.csv(GSPC, 'data/sp500.csv', row.names = FALSE ) 
sp500 = read.csv('data/sp500.csv', stringsAsFactors = FALSE)
# по умолчанию R записывает названия столбцов (row names). если не указано иное, это просто нумерация строк # по порядку - 1,2, 3 и так далее. Нам не нужен столбец, поэтому row.name = FALSE
str(sp500)
```

Как мы уже знаем, команда `str` показывает структуру объекта и указывает, что необходимо изменить формат столбца `data` из-за того, что он имеет тип `factor`. 

## Чтение/запись данных из фойлов Excel 

В R существует несколько пакетов для работы с файлами Excel. Я рекомендую использовать пакет `readxl`, если вам нужно только прочитать данные из Excel и пакет `openxlsx`, если вам необходимо записывать  

```{r}
file <- 'cbpol_1810.xlsx'
dat <- openxlsx::read.xlsx(xlsxFile = file, sheet = "Monthly Series", startRow = 4, detectDates = TRUE )
tail(dat)

```


## Индекс S&P 500 -- долгосрочная динамика фондового рынка

Наиболее простой и популярный тип визуализации финансовых данных -- график временного ряда, где по оси Х находятся время, по оси Y -- значение 

```{r}
# преобразовать xts в data.frame
data <- sp500[,c('GSPC.Adjusted', 'date')]
data$date <- as.Date(data$date)

```


```{r, warning=FALSE, message=FALSE}
# Set up the plot axes, but don't actually plot the data (type = "n")

library(plotly)
plot_ly(data = data, x= ~date) %>%
   add_lines(y = ~GSPC.Adjusted)

```

## График OHLC

Часто визуальное предоставление финансовых серий осуществляется с помощью графиков OHLC (Open - High - Low - Close)

```{r echo=TRUE, message=FALSE}
library(quantmod)
quantmod::candleChart(GSPC['2019::'], theme = 'white', name = 'Индекс S&P500 в 2019 году')
tail(GSPC)

```


+ `Open` -- цена открытия (начало торгового дня)
+ `High` -- максимальная цена за период 
+ `Low` -- минимальная цена за период  
+ `Close` -- цена закрытия 
+ `Volume` -- цена закрытия 
+ `Adjusted` -- цена закрытия с учетом корректировок на выплату дивидендов и разделение (split) акций 

## Вариант графика OHLC -- bar chart

```{r,warning=FALSE, message=FALSE, echo=TRUE}

barChart(GSPC['2018::'], theme = 'white', name = 'Индекс S&P500 в 2018 году (bar chart)')

```

## Внутридневные (intraday) данные

+ Для дневных серий обычно используют цены закрытия торгового дня (close price). Обратите внимание, что время закрытия для разных торговых площадок может отличаться. Пример -- оценка корреляции между ценой на нефть WTI на NYMEX (время закрытия -- 21-30 по МСК) и курсом RUB/USD (фиксинг - 12-00 МСК предыдущего дня, время основной сессии на Московской Бирже -- c 10-00 до 15-15 и так далее). Эти различия имеют значение на современных рынках. 
+ Финансовые данные зачастую доступны с очень высоким разрешением -- вплоть до мониторинга данных по каждым отдельным торговым операциям (tick data)
+ Многие современные финансовые рынки функционируют в круглосуточном режиме. К примеру, валютные рынки устроены подобным образом. 
+ Скорость обработки информации за последние 10-15 лет выросла драматическим образом. Поэтому реакция рынки на те или иные события очень быстрая. Использование дневных данных не позволяет оценивать эти эффекты. 
+ Как правило, у вас нет ограничений использовать только дневные данные, внутридневные данные доступны в специализированных системах и базах данных, иногда -- бесплатно.  
+ Внутридневные данные занимают много места и требуют много вычислительных ресурсов для обработки. 

## Торговля RUB/USD на прошлой неделе - данные за каждые 15 минут 

+ Используем пакет QuantTools для доступа к данным валютной секции ММВБ
+ `Sys.Date()` -- это текущая дата (то есть, сегодня), `Sys.Date()-5` -- это пять дней назад. 

```{r, warning=FALSE, echo=TRUE, message=FALSE}
require(QuantTools)
rub = get_finam_data('USDRUB', from = Sys.Date()-5, to = Sys.Date(), period = "15min")
rub = quant_tools_to_xts(rub)
quantmod::candleChart(rub, theme='white', name = 'Динамика торгов долларом США \n на прошлой неделе')

```

## Преобразование данных -- изменение периодичности

Чаще все в рамках построения финансовых моделей мы не работаем не с исходными данными непосредственно, а осуществляем преобразования данных для того, чтобы привести их в нужную форму. Преобразования могут быть следующими: 

+ Переход от дневных к месячным/недельным данным или от внутридневных данных -- к дневным. Можно перейти от данных меньшей размерности -- к большей, но не наоборот. То есть, к примеру, невозможно перейти от недельных данных -- к дневным. 
+ Функции `to.xxx` из пакета `xts` позволяют легко осуществлять подобные преобразования. Для данных OHLC функция осуществляет корректный расчет максимальных/минимальных значений за период, а также величины объемы торгов (столбец `Volume`)

```{r, echo=TRUE}
periodicity(GSPC) # исходная перодичность данных 
tail(to.monthly(GSPC))
tail(to.quarterly(GSPC))
```

## Преобразование данных -- изменение периодичности

+ Выбор определенного периода времени для анализа. Объекты типа `xts` позволяют осуществлять выборку данных внутри квадратных скобок 

```{r, echo=TRUE}
head(GSPC['2017']) # весь 2017 год
tail(GSPC['/2017']) # все по 2017 год
head(GSPC['2017/2017-03']) # c январь по март 2017 года 
```

## Преобразование данных -- первые/последние элементы

+ Функции `xts::first` и `xts::last` позволяют вам получить первые или последние элементы объекта `xts`. Второй аргумент фукнций позволяет задавать количество периодов, которое нам необходимо.
+ Названия функций first/last используются в других пакетах, поэтому используется синтаксис `xts::first`. Это  означает использовать функцию `first` именно из пакета `xts`. 

```{r, echo=TRUE}
xts::last(GSPC, '1 week') ## последняя неделя 
xts::last(GSPC, '3 days') ## последние три дня 
```



##  Преобразование данных --  логарифм 

Используйте лог-преобразование для того, чтобы скорректировать серию на экспоненциальный рост и "ограничить" волатильность. 

```{r, warning=FALSE, message=FALSE}

par(mfrow = c(1,2))
fancy.plot(index(GSPC),GSPC$GSPC.Adjusted, t="l", xlab="Дата", ylab="Исходный уровень", col=2)
fancy.plot(index(GSPC),log(GSPC$GSPC.Adjusted), t="l", xlab="Дата", ylab="Лог", col=2)
par(mfrow = c(1,1))
```

```{r}
```


Параметр `mfrow = c(nrow, ncols)` отвечает за комбинирование графиков на одном листе. Команда создает матрицу из `nrows` строк и `ncols`столбцов, которая заполняется графиками по строкам. 

## Регрессия логарифма S&P по времени

+ Посчитаем простую линейную регрессию зависимости абсолютного лог-значения индекса SP500 от времени c помощью функции `lm`.

```{r, echo=TRUE}
head(data)
names(data)[1] <- 'sp500'
data$sp500.log <- log(data$sp500)
time <- 1:nrow(data)
model.time <- lm(data$sp500.log ~ time)
summary(model.time)
```

Сравним фактические данные и модельную регрессию: 

```{r, echo=FALSE}
fancy.plot(time, data$sp500.log, type="l", col=2, ylab="Log(S&P 500)", hguide=3, xlab = 'Время (дни)')
abline(model.time, col=1, lty=2)

```

## Может ли вчерашнее значение индекса предсказать нам значение сегодня?

```{r, echo=TRUE}
data$sp500.lag.log <- c(NA, lag(data$sp500.log)[-nrow(data)])
fancy.plot(data$sp500.lag.log, data$sp500.log, cex=0.5, col=2, xlab="Значение вчера Log(S&P 500)", ylab="Значение сегодня Log(Dow)", asp=1)

```

## Может ли вчерашнее значение индекса предсказать нам значение сегодня? (2)

Посчитаем регрессию

```{r, echo=TRUE}
model.yest <- lm(data = data, sp500.log ~ sp500.lag.log)
print(summary(model.yest), digits=6)
confint(model.yest)
```

Похоже, что не очень. Согласно посчитанной регрессии, "сегодня" будет таким же, как вчера ($\beta = 1$).

! В финансовых данных обычно наблюдения, которые находятся "рядом"" другом с другом, **скоррелированны между собой**. 

## Гистограмма лог-значений -- проверка допущений

Гистограмма  указывает на то, что моменты распределения не являются устойчивыми. Использование данных в такой форме ("в уровнях") не очень осмысленно.

```{r}
hist(data$sp500.log, breaks=50, col=2, xlab="Log(S&P 500)", main="Гистограмма лог-значений S&P 500")
```

Может быть, надо преобразовать значения серии?

## Доходность 

Доходность -- лог-значение "сегодня" минус лог-значение "вчера" или **лог-доходность**

```{r, echo=TRUE}
data$sp500.ret <- data$sp500.log - data$sp500.lag.log
fancy.plot(data$date, data$sp500.ret, t="l", xlab="Дата", ylab="Лог-доходность", col=2)

#diff(log(GSPC$GSPC.Close)) - расчет лог-доходности для объектов xts 

```

## Нетто-доходность

Пусть $P_t$ это цена финансового актива в момент времени $t$. Если мы предположим, что в этот период не было выплат дивидендов, то **нетто-доходность** за период владения со времени $t-1$ до времени $t$ составит

$$ R_t = \frac{P_t}{P_{t-1}} -1 = \frac{P_t - P_{t-1}}{P_{t-1}} $$

Числитель -- прибыль, полученная за период владения, отрицательное значение означает убыток. 

Знаменатель -- первоначальная инвестиция, сделанная в начале периода владения. 
Минимальное значение доходности = -1, то есть 100% убыток или потеря всей первоначальной инвестиции. 

$$ R_t \geq -1 $$

## Валовая доходность

Валовая доходность определяется как:

$$ \frac{P_t}{P_{t-1}} = 1 + R_t $$

Доходности не зависят от размерности исходных величин (доллары, рубли и проч.)
Размерность доходности -- время. Она зависит от единиц $t$ (час, день, неделя, год). 

Валовая доходность за последние $k$ периодов является произведением доходностей за каждый из периодов: 

$$ 1 + R_t(k) = \frac{P_t}{P_{t-k}}  = (\,\frac{P_t}{P_{t-1}})\,(\frac{P_{t-1}}{P_{t-2}}) ... (\frac{P_{t-k+1}}{P_{t-k}}) $$

## Лог-доходность (continuously compounded return)

Лог-доходность или `continuously compounded returns`  определяются как: 

$$ r_t = log(1 + R_t) = log(\frac{P_t}{P_{t-1}}) = p_t - p_{t-1} $$

где $p_t = log(P_t)$ -- лог-цена. 

Лог-доходности примерно равны доходностям из-за того, что если $x$ достаточно малая величина, то $log(1+x) \approx x$

```{r}
retseq <- seq(-.5, .5, length=100)
 plot(retseq, log(retseq + 1), type="l",
      axes=FALSE, col="blue", lwd=3, xlab="простая доходность", ylab="Лог доходность")
 axis(1, at=c(-.5,-0.25, 0, 0.25, .5), label=c("-50%", "-25%", "0%", "25%", "50%"))
 axis(2, at=c(-.5,-0.25, 0, 0.25, .5), label=c("-50%", "-25%", "0%", "25%", "50%"))
 abline(0,1, lty=2, lwd = 2, col="red")
```


+ Чем более короткий промежуток времени (дни, часы, минуты) мы используем, тем меньше будет доходность меньше по абсолютным значениям.Поэтому мы можем ожидать, что доходности будут примерно равно лог-доходностям для дневных и внутридневных данных. Для годовых данных, к примеру, ошибка будет гораздо больше -- для них не стоит использовать такое преобразование.
+ Доходности и лог-доходности имеют одинаковый знак 
+ Лог-доходности на всех промежутках значениях больше простой доходности. По мере приближения обычной доходности к -1 (потеря всех инвестиций), лог-доходность стремится к $-\infty$

## Корректировка на дивиденды для акций 

+ Многие компании, особенно из традиционных секторов, платят дивиденды, которые должны быть учтены при оценке **полной  доходности (total return)**.  
+ Если мы не учитываем эту компоненту, то мы рискуем неправильно оценивать доходности для инвесторов и исказить результаты анализа. 
+ Иногда компании проводят разделение акций (stock split), то есть обмен "старых" акций на "новые" в определенном соотношении. К примеру, каждый владелец 1 старой акции получает 2 новых. В этих операциях нет экономической сути, они делаются просто для удобства котирования цен и/или по историческим причинам.  


## Акции Exxon Mobil - 1

```{r}
chartSeries(XOM$XOM.Close['1990::'], name = 'Цена акций Exxon Mobil \n (без корректировки на дивиденды и разделения акций)',multi.col = FALSE, theme  = 'white')
```

## Акции Exxon Mobil - 2

```{r}
chartSeries(XOM$XOM.Adjusted['1990::'], name = 'Цена акций Exxon Mobil \n (без корректировки на дивиденды и разделения акций)',multi.col = FALSE, theme  = 'white')
```

## Порядок корректировки цены акции на дивиденды

+ Если дивиденды выплачиваются до периода времени $t$, то валовая доходность в момент времени $t$ определяется как 

$$ 1+ R_t = \frac{P_t + D_t}{P_{t-1}} = \frac{P_t}{P_{t-1}} + \frac{D_t}{P_{t-1}} $$ 


Нетто-доходность будет $r_t = log(1+R_t) = log(P_t + D_t) - log(P_{t-1})$.

+ Для дневных доходностей, дивидендная доходность равна нулю во все дни, когда не выплачиваются дивиденды. 
Для компаний, которые не выплачивают дивиденды, полная доходность и ценовая доходность равны друг другу. 
+ Для скорректированной (adjusted) цены акции стоимость дивидендов вычитается из цены закрытия на дату "отсечки". Дата "отсечки" -- последняя дата, на которую признается право акционера на получение дивидендов. 
+ Предположим, что цена закрытия акций Роснефти составила 300 рублей в четверг. После закрытия торгов Роснефть объявила о том, что выплатит дивиденды в размере на 10 рублей на акцию. Тогда скорректированная цена акции составит 290 рублей = 300 - 10. 
+ Корректировка на дивиденды "меняет"" цены в прошлом. Текущая скорректированная цена и текущая цена на рынке должны быть равны другу другу. Поэтому корректируются именно исторические данные, а не текущие. 


## Полная доходность (total return) для акций Газпрома

+ Для многих российских бумаг, разница между полной доходностью и ценовой доходностью также важна!
+ В Bloomberg можно оценивать total return для российских бумаг 

<div align="center">
  <img src="fig/GAZP-total-return-2.png" width="1011" height="520" />
</div>

К сожалению, доступные бесплатные источники не предоставляют информацию по полной доходности для российских активов. 
Bloomberg предоставляет данные по дивидендам и total return для российских бумаг. 

## Сравнение доходностей нескольких бумаг за период времени 

нарисуем график трех бумаг -- Amazon, Google и Facebook. 
Акции Facbook торгуются с мая 2012 года (IPO). Поэтому график начинается с 18 мая 2012 года. 

```{r}
symbols = c('AMZN', 'GOOG', 'FB')
getSymbols(symbols,src="yahoo", from ='2012-05-18') # from yahoo finance 
tech_stocks = merge(AMZN$AMZN.Adjusted, GOOG$GOOG.Adjusted, FB$FB.Adjusted )
names(tech_stocks) = c('AMZN', 'GOOG', 'FB')
plot.xts(tech_stocks,legend.loc = 'top', main = 'Динамика цен на акций интернет-компаний')

```

нормируем график по состоянию на 18 мая 2012 года -- поделим значения каждой бумаги на соответствующее значение в этот день:

```{r, echo=TRUE}
library(xts)
tech_stocks2 <- tech_stocks
tech_stocks2$AMZN <- tech_stocks2$AMZN / as.numeric(xts::first(tech_stocks2$AMZN))
tech_stocks2$GOOG <- tech_stocks2$GOOG / as.numeric(xts::first(tech_stocks2$GOOG))
tech_stocks2$FB <- tech_stocks2$FB / as.numeric(xts::first(tech_stocks2$FB))

plot.xts(tech_stocks2,legend.loc = 'top', main = 'Нормированная динамика цен на акций интернет-компаний')

```


## Позволяет ли доходность вчера предсказать доходность сегодня?

```{r}
data$sp500.ret.lag <- c(NA, data$sp500.ret[-nrow(data)])
fancy.plot (data$sp500.ret.lag, data$sp500.ret, col=2, cex=0.5, xlab="Доходность вчера", ylab="Доходность сегодня", asp=1)

```

## Позволяет ли доходность вчера предсказать доходность сегодня? (2)

посчитаем регрессию для доходностей

```{r, echo=TRUE}
model.ret <- lm(data = data, sp500.ret ~ sp500.ret.lag)
summary(model.ret, digits = 4)
```


## Гистограмма доходностей -- похожа на нормальное распределение?



```{r,r, warning=FALSE, echo=TRUE}
hist(data$sp500.ret, breaks=100, col=2, xlab="Доходность", main="")
```

Доходности возвращаются к среднему значению (mean reversion)

```{r, warning=FALSE}
library(ggplot2)
ggplot(tail(data,1000), aes(x=sp500.ret)) + 
   geom_histogram( aes(y=..density..),
                   colour="black", 
                   fill="white") +
   stat_function(fun=dnorm, args=list(mean=mean(data$sp500.ret, na.rm=TRUE), sd=sd(data$sp500.ret, na.rm=TRUE)), col = 'red') + theme_minimal()

```


## Моменты случайной величины 

Серия по доходности финансового актива -- случайная величина, которая имеет некоторое распределение. Для того, чтобы лучше описать это распределение, можно оценить его **моменты**. 

Среднее арифметическое (или ожидаемое значение) -- определяет центральную тенденцию случайной величины. Для финансовых активов обычно интересен вопрос о том, является ожидаемое значение равным нулю. 

Второй момент определяет изменчивость или дисперсию случайной величины. Для финансовых активов среднеквадратическое отклонение (квадратый корень дисперсии) определяет степень риска. 

Два первых момента уникальным определяют нормальное распределение. Для других распределелий моменты более высокого порядка могут представлять интерес. 

## t-критерий Стьюдента

Мы можем использовать t-критерий для проверки гипотезе о равенстве среднего арифметического серии доходностей нулю. 

$ H_0:  \mu= 0, H_1: \mu \neq 0 $


```{r}

eurusd <- getSymbols("DEXUSEU", src="FRED", auto.assign = FALSE) #  U.S. / Euro Foreign Exchange Rate 
eurusd.ret <- diff(log(eurusd$DEXUSEU)) # расчет лог-доходности 
plot(eurusd.ret)
```

```{r, warning=FALSE}
t.test(eurusd.ret)
```

p-value отражает вероятность получения таких наблюдаемых значений теста при условии, что нулевая гипотеза верна. МЕНЬШЕЕ значение p-value означает больше оснований в пользу альтернативной гипотезы ($H1$). 


## Эксцесс и нормальность доходностей

+ Эксцесс (kurtosis) -- мера "остроты" пика распределения случайной величины. 
+ Эксцесс нормально распределенный величины равен 3. Поэтому обычно в формуле эксцесса вычитают 3 для того, чтобы  коэффициент эксцесса нормального распределения был равен нулю. Он положителен, если пик распределения около математического ожидания острый, и отрицателен, если пик очень гладкий.
 
```{r, echo =TRUE, warning=FALSE}
require(nortest)
e1071::kurtosis(data$sp500.ret, na.rm=TRUE) # избыточный эксцесс(excess kurtosis), 0  -- для нормального распределения 
nortest::ad.test(data$sp500.ret) 
qqnorm(data$sp500.ret) # график кванталь-квантиль 
qqline(data$sp500.ret)
```

Доходности имеют избыточный эксцесс ("тяжелые хвосты" -- **heavy tails**).

## Волатильности устойчивы (persistent) во времени 

квадраты доходностей

```{r, echo=TRUE}
fancy.plot(data$date, (data$sp500.ret)^2, t="l", xlab="Date", ylab="Квадрат доходности", col=2)
mod.vol <- lm(data =data, sp500.ret^2 ~ sp500.ret.lag^2)
cor(data$sp500.ret,data$sp500.ret.lag, use = "complete.obs" )
cor(data$sp500.ret^2,data$sp500.ret.lag^2, use = "complete.obs" )
```

```{r}
fancy.plot(data$date, abs(data$sp500.ret), t="l", xlab="Date", ylab="Абсолютное значение доходности", col=2)
```

## Основные особенности финансовых серий: 

1. Многие финансовые серии растут **экспоненциально** и имеют изменяющуюся волатильность в зависимости от уровня значений.
2. Наблюдения, которые находятся рядом, скоррелированны между собой. 
3. Доходности имеют избыточный эксцесс (**heavy tails**) и **не распределены** нормально.
4. Волатильность устойчива во времени (persistent) и часто в финансовых данных наблюдаются **кластеры волатильности** - периоды большой и низкий волатильности сохраняются определенное время.

## Понятие стационарности и почему оно важно

+ Стандартным допущением при анализе временных рядов является **стационарность**. 
+ Серия является стационарной, если параметры генерирующего процесса (обычно это среднее и дисперсия) не меняются со временем
+ Рассмотрим две серии А и B. Параметры серии А (среднее арифметическое, стандартное отклонение) - не меняются со временем

```{r, echo=TRUE}
mu = 0
sigma = 1
T = 100
A <- rnorm(T, mu, sigma)
plot(A, type = 'l')
```

## Понятие стационарности и почему оно важно (2)

Для серии B среднее (mean) меняется со временем 

```{r, echo=TRUE}
mu = 0
sigma = 1
T = 100
B <- rep(0, 100)
t <- seq(0,T, by = 1)

for(i in 1:T){
   B[i] <- rnorm(1, 0.05*i, sigma)
}

plot(B, type = 'l')

```

## Почему не-стационарнасть опасна?

+ Многие статистические цены требуют, чтобы данные, которые тестируются, были стационарны. 

К примеру, возьмем среднее для не-стационарного ряда (серия B, сгенерированная ранее): 

```{r}
plot(B, type = 'l')
abline(h = mean(B), col = 'red')
```

+ Рассчитанное среднее значение для всех точек бессмысленно с точки зрения прогнозирования будущих значений. 
+ Устойчивость параметров во времени дает основания считать, что рассчитанные по прошлым данным параметры, будут иметь значение и в будущем. 


Проверим стационарность с помощью стандартного теста 
```{r, echo=TRUE}
library(tseries)
adf.test(A)
adf.test(B)
```

Тесты иногда ошибаются! 


## Использованные источники: 

1. "An Introduction to Analysis of Financial Data with R" (Ruey S. Tsay)
2. "Statistics and Data Analysis for Financial Engineering" (David Ruppert & David Matteson)
3. Analyzing Financial Data and Implementing Financial Models Using R (Clifford Ang)
4. Forecasting Financial Time Series (Patrick Perry)
